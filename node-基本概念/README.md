

# node作为服务器运行时的逻辑（事件驱动的本质）

通过`主循环`加`事件触发`的方式加上`异步非阻塞I/O`的特点运行程序

想要了解这句话我们应该对这几个名词有所了解

1. 异步非阻塞I/O
2. 单线程
3. 主循环
4. 观察者

## 异步非阻塞I/O

I/O 是指   `Input output system` ,中文全称为`输入输出系统`

我们时常会听到异步，非阻塞混在一起介绍，下面我们将在下方介绍`异步/同步` `阻塞/非阻塞`这两种概念 

### 阻塞/非阻塞

<img src="https://github.com/JianpanBucuo/node_package/blob/master/node-基本概念/async-sync.png" width="941" height="495"/>

#### 阻塞I/O

在调用系统内核之后一定要等到系统内核层面完成所有操作后，才返回应用层调用才结束。

以读取磁盘上的一段文件为例，系统内核在完成磁盘寻道，读取数据，复制数据到内存中之后，这个调用才结束

- 阻塞I/O造成CPU等待I/O，浪费等待事件，CPU的处理能力不能得到充分利用



#### 非阻塞I/O

在调用系统内核之后，不带数据直接返回到应用层，要获取数据，还需要通过文件描述符再次读取

优点：在非阻塞I/O返回后，CPU的时间片可以用来处理其他事物，此时的性能提升是明显的。

缺点：由于调用非阻塞I/O后返回的不是应用层期望的数据，而仅仅是当前调用的状态。为了获取完整的数据，应用程序需要重复调用I/O操作来确认是否完成

### 同步/异步

是同步还是异步的区别可以理解为被调用者*是否主动*告诉调用者结果


`非阻塞同步I/O：需要轮询去确认是否完成数据获取`

`非阻塞异步I/O：等待I/O完成后的通知，执行回调，用户无需考虑轮询`

介绍完`非阻塞I/O`和`同步/异步`的概念后我们将通过node执行模型介绍node是如何实现`异步I/O`的

### 单线程

我们经常提到node是单线程的

这里的单线程仅仅只是Javascript执行在单线程中，除了这部分以外，很多部分都是多线程的

I/O操作实际上是交给libuv来做的，而libuv提供了完整的线程池，所以I/O操作都是可以并行的

<img src="https://github.com/JianpanBucuo/node_package/blob/master/node-基本概念/component.png" width="395" height="368"/>
 

### 事件循环机制 - node执行模型

在进程启动时，node便会创建一个类似于while(true)的循环，每执行一次循环体的过程我们称之为*Tick*。每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及相关的回调函数并执行它们。然后进入下一个循环（Tick）。如果不再有时间处理，就退出进程。

<img src="https://github.com/JianpanBucuo/node_package/blob/master/node-基本概念/event_circle.png" width="456" height="484"/>

Tick过程中如何判断是否有事件待处理呢？ 这里必须要引入的概念是`观察者`

#### 观察者

在Tick的过程中有一个或多个观察者，而判断是否有事件待处理的过程就是向这些观察者询问是否有要处理的事件

在node中事件主要来源于网络请求，文件I/O等，这些事件的观察者有*文件观察者* *网络观察者*

#### 异步I/O过程

- 从Javascript发起调用到内核执行完I/O操作的过程中，存在一种中间产物，叫做请求对象

1. javascript调用核心模块并立即返回到javascript线程，执行当前任务的后续操作
2. I/O操作结束后会将数据存储在请求对象上，并通知IOCP
3. I/O观察者查看IOCP是否有执行完的请求，如果存在，会将请求对象加入I/O观察者队列中，然后将其当作事件处理
 
## Node的优势/缺点

### 单线程的优势/缺点

优势

1. 利用单线程，远离多线程死锁，状态同步等问题
2. 没有线程上下文交换所带来的性能上的开销
3. 利用异步I/O，让单线程远离阻塞，以更好的提高CPU利用率

缺点

1. 无法利用多核CPU
2. 错误会引起整个应用退出，应用的健壮性值得考虑
3. 大量计算占用CPU导致无法继续调用异步I/O

`Javascript长时间的执行会导致后续的异步I/O发不出调用，已完成的异步I/O的回调函数也会得不到及时执行`

node采用了`child process`来解决单线程中大计算量的问题

子进程的出现，意味着node可以地应对单线程在健壮性和无法利用多核CPU方面的问题。
通过将计算分发到各个子进程，可以将大量计算分解掉，然后再通过进程之间的事件消息来传递结果。
通过Master-Worker的管理方式，也可以更好地管理各个工作进程，以达到更高的健壮性

 `总结：node以事件驱动的方式处理请求，无须为每一个请求创建额外的对应线程，可以省掉创建线程和销毁线程的开销，同时操作系统在调度任务时因为线程较少，上下文切换的代价很低，这使得服务器可以有条不紊的处理请求`

## node的应用场景

### I/O密集型

node擅长`I/O密集型`的应用场景，node面向网络且擅长并行I/O，能够有效的组织起更多的硬件资源。

`I/O密集的优势主要在于Node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用较少`

### CPU密集型

由于Javascript单线程的原因，如果有长时间的运算（大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起。可以适当调整和分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起，这样既可同时享受到并行I/O的好处，又能充分利用CPU

`对于长时间的计算，如果它的耗时超过普通阻塞I/O的耗时，那么应用场景就需要重新评估，因为这类计算比阻塞I/O还影响效率，甚至说是一个纯计算的场景。此类应用场景应当采用多线程的方式进行计算。`